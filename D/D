#!/usr/bin/env python3

import json, sys, socket, pickle
from json import JSONDecodeError
import logging

# Setting base Log level
logging.basicConfig(level=logging.DEBUG)

sys.path.append('../')


def is_valid_array(object):
    is_array = isinstance(object, list)
    if is_array:
        if len(object) >= 2 and isinstance(object[0], str):
            return is_valid_keyword(object)
    else:
        return False


def is_valid_keyword(object):
    command_name = object[0]
    if command_name == 'lab':
        logging.debug('Is valid dictionary for %s is %r', object[1:], is_valid_dictionary(object[1:]))
        return is_valid_dictionary(object[1:]) \
        and is_pairwise_distinct(object[1:])
    elif command_name == 'add':
        return is_valid_color(object[1])
    elif command_name == 'move':
        return is_valid_color(object[1])
    else:
        return False


def is_pairwise_distinct(object):
    edges_dictionary = {}
    for entry in object:
        from_node = entry.get('from')
        to_node = entry.get('to')

        # checks if the to node is in the list of edges for the from node
        if(edges_dictionary.get(from_node, "empty key") != "empty key"):
            if to_node in edges_dictionary[from_node]:
                return False

        # checks if the from node is in the list of edges for the to node
        elif(edges_dictionary.get(to_node, "empty key") != "empty key"):
            if from_node in edges_dictionary[to_node]:
                return False
        edges_dictionary.update({to_node:from_node})

    return True


def is_valid_dictionary(object):
    for entry in object:
        is_dictionary = isinstance(entry, dict)
        if is_dictionary:
            if not is_valid_dictionary_key(entry):
                return False
        else:
            return False
    return True


def is_valid_dictionary_key(object):
    if len(object.keys()) < 2:
        return False
    else :
        first_key = list(object.keys())[0]
        second_key = list(object.keys())[1]
        return first_key == 'from' and second_key == 'to'


def is_valid_color(color):
    return color == "white" or color == "black" or color == "red" or color \
    == "green" or color == "blue"

# 1. the IP address of the server
# 2. the destination port, and
# 3. the userâ€™s name.
def read_command_line():
    ip_addr = 'localhost'
    port_num = 8000
    user_name = 'John Doe'

    if len(sys.argv) == 4:
         ip_addr = sys.argv[1]
         port_num = sys.argv[2]
         user_name = sys.argv[3]
    elif len(sys.argv) == 3:
         ip_addr = sys.argv[1]
         port_num = sys.argv[2]
    elif len(sys.argv) == 2:
         ip_addr = sys.argv[1]

    return ip_addr, port_num, user_name

def send_user_name(s, user_name):
    s.sendall(pickle.dumps(user_name))

# takes the input and flattens it into one list
def flatten_input():
    input_in_one_line = ""
    for input_string in sys.stdin:
        input_string = input_string.strip()
        input_in_one_line = input_in_one_line + input_string
    return input_in_one_line

# processes the jsons from the list of input and filters out the poorly formatted
# client requests
def extract_json(input_in_one_line):
    temp = ""
    list_of_well_formed_jsons = []
    for character in input_in_one_line:
        temp = temp + character
        try:
            temp_json = json.loads(temp)

            if is_valid_array(temp_json):
                list_of_well_formed_jsons.append(temp_json)
            else :
                print('Not a request: ', temp_json)
                continue
            temp = ""

        except JSONDecodeError:
            # load throws JSONDecodeError if json is invalid
            continue

    return list_of_well_formed_jsons

# Converts from client input to server input
def convert_to_server_input(json_recv):
    edges = []
    edges_dict = {}
    for element in json_recv:
        if element == "lab":
            continue
        from_elem = element["from"]
        to_elem = element["to"]
        edges_dict[from_elem] = to_elem
        edges.append((from_elem, to_elem))

    logging.debug("Edges: %s", edges)
    edges_keys = list(edges_dict.keys())
    edges_values = list(edges_dict.values())

    node_list = edges_keys + list(set(edges_values) - set(edges_keys))
    logging.debug("Nodes: %s", node_list)

    return_string = ["lab", node_list, edges]
    logging.debug("return lab string: %s", return_string)

    return return_string

# sends the well formed client requests to the server
def send_json(list_of_well_formed_jsons, s):
    json_bytes = bytearray(str(json), 'utf-8')
    logging.debug("Sending to Server: %s", list_of_well_formed_jsons)
    batch_commands = []
    for cur_json in list_of_well_formed_jsons:
        current_command = cur_json[0]
        logging.debug("Current JSON: %s", cur_json)
        logging.debug("JSON type: %s", type(cur_json))
        if current_command == "lab":
            s.sendall(pickle.dumps(convert_to_server_input(cur_json)))
        else:
            batch_commands.append(cur_json)
    s.sendall(pickle.dumps(batch_commands))

# receives the response from the server for the given requests
def receive_json(s):
    data_received = pickle.loads(s.recv(512))
    print('Message from server:', data_received)

def receive_session_id(s):
    session_id = pickle.loads(s.recv(512))
    print('The session id is: ', session_id)

# values will be read if they are well formed if not they will be ignored
# if an invalid (incomplete or unparsable) json is entered all following inputs
# will be ignored
def read_in():
    sort_up = True

    ip_addr, port_num, user_name = read_command_line()

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_addr, port_num))

    send_user_name(s, user_name)
    receive_session_id(s)

    while True:
        input_in_one_line = flatten_input()
        list_of_well_formed_jsons = extract_json(input_in_one_line)
        print("accepted input: ",  list_of_well_formed_jsons)
        send_json(list_of_well_formed_jsons, s)
        receive_json(s)


if __name__ == '__main__':
    read_in()
